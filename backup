#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:
# Copyright (C) 2019-2023 J. Nathanael Philipp (jnphilipp) <nathanael@philipp.land>
# backup: Easily configure and reproducibly run complex backups.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""backup: Easily configure and reproducibly run complex backups."""

import gzip
import logging
import shlex
import socket
import subprocess
import sys
import time

from argparse import (
    ArgumentDefaultsHelpFormatter,
    ArgumentParser,
    FileType,
    RawTextHelpFormatter,
)
from dataclasses import dataclass, field
from enum import Enum
from lxml import etree
from pathlib import Path
from time import sleep
from threading import Thread
from typing import Dict, List, Optional, Set, TextIO, Tuple, Type, TypeVar, Union


__author__ = "J. Nathanael Philipp (jnphilipp)"
__copyright__ = "Copyright 2019-2023 J. Nathanael Philipp (jnphilipp)"
__email__ = "nathanael@philipp.land"
__license__ = "GPLv3"
__version__ = "0.5.0"
__github__ = "https://github.com/jnphilipp/backup"


VERSION = (
    f"%(prog)s v{__version__}\n{__copyright__}\n"
    + "License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>."
    + "\nThis is free software: you are free to change and redistribute it.\n"
    + "There is NO WARRANTY, to the extent permitted by law.\n\n"
    + f"Report bugs to {__github__}/issues."
    + f"\nWritten by {__author__} <{__email__}>"
)
NAMESPACE = {"p": "https://github.com/jnphilipp/backup/"}


class ArgFormatter(ArgumentDefaultsHelpFormatter, RawTextHelpFormatter):
    """Combination of ArgumentDefaultsHelpFormatter and RawTextHelpFormatter."""

    pass


class Tool(str, Enum):
    """Supported backup tools."""

    RSYNC = "rsync"
    TAR = "tar"


@dataclass
class Database:
    """Dataclass for databases."""

    T = TypeVar("T", bound="Database", covariant=True)

    name: str
    user: str
    password: Optional[str] = None
    options: Optional[str] = None
    ssh: Optional[str] = None
    ssh_args: List[str] = field(default_factory=list)
    target: Optional[Path] = None

    @classmethod
    def from_xml(cls: Type[T], e: etree.Element, default_target: Optional[Path]) -> T:
        """Create database from XML.

        Args:
         * e: XML Element
         * default_target: default if not otherwise specified.

        Returns:
         * Instance of database.
        """
        db = cls(
            name=e.find("p:name", namespaces=NAMESPACE).text.strip(),
            user=e.find("p:user", namespaces=NAMESPACE).text.strip(),
        )

        if e.find("p:password", namespaces=NAMESPACE) is not None:
            db.password = e.find("p:password", namespaces=NAMESPACE).text.strip()
        if e.find("p:target", namespaces=NAMESPACE) is not None:
            db.target = e.find("p:target", namespaces=NAMESPACE).text.strip()
        else:
            db.target = default_target
        if e.find("p:options", namespaces=NAMESPACE) is not None:
            db.options = e.find("p:options", namespaces=NAMESPACE).text.strip()
        if e.find("p:ssh", namespaces=NAMESPACE) is not None:
            ssh = e.find("p:ssh", namespaces=NAMESPACE)
            db.ssh = ssh.text.strip()
            db.ssh_args = (
                shlex.split(ssh.attrib["args"]) if "args" in ssh.attrib else []
            )

        return db

    def _get_password(self) -> Optional[str]:
        return self.password

    def _run(
        self, args: List[str], env: Dict[str, str], target: Path
    ) -> subprocess.Popen:
        with gzip.open(target, "wt", encoding="utf8") as f:
            pobj = subprocess.Popen(
                args,
                stdout=subprocess.PIPE,
                env=env,
                stderr=subprocess.PIPE,
                encoding="utf8",
            )

            assert pobj.stdout is not None

            for line in pobj.stdout:
                f.write(line)

            pobj.wait()
            return pobj

    def build_command_args(self) -> List[str]:
        """Build cmd command arguments."""
        raise NotImplementedError()

    def backup(self, dry_run: bool = False):
        """Make backup."""
        raise NotImplementedError()


@dataclass
class PostgreSQL(Database):
    """Dataclass for PostgreSQL databases."""

    def build_command_args(self) -> List[str]:
        """Build cmd command arguments."""
        password = self._get_password()

        if self.ssh is None:
            args: List[str] = []
        elif password is None:
            args = ["ssh", self.ssh] + self.ssh_args
        else:
            args = ["ssh", self.ssh] + self.ssh_args + [f"PGPASSWORD={password}"]
        args.append("pg_dump")
        args.append(f"--username={self.user}")
        if self.options is not None:
            args += self.options.split(" ")
        args.append(self.name)
        return args

    def backup(self, dry_run: bool = False):
        """Make backup."""
        env: Dict[str, str] = {}
        if self.ssh is None:
            s = self._get_password()
            if s is not None:
                env["PGPASSWORD"] = s

        args = self.build_command_args()
        cmd = '" "'.join(
            ["PGPASSWORD" if a.startswith("PGPASSWORD") else a for a in args]
        )
        logging.info(f"Dumping PostgreSQL database {self.name}.")
        logging.debug(f'Running PostgreSQL command: "{cmd}"')

        hostname = self.ssh if self.ssh is not None else socket.gethostname()
        path = Path(hostname) / "db-dumps" / "PostgreSQL" / self.name
        if self.target is not None:
            path = self.target / path
        path = path.absolute()
        if not path.exists() and not dry_run:
            path.mkdir(parents=True, exist_ok=True)

        path /= f"{self.name}_{timestamp()}.sql.gz"
        logging.debug(f"Storing {self.name} dump in {path}.")

        if dry_run:
            logging.info(" ".join([f"{k}={v}" for k, v in env.items()]))
            logging.info(" ".join(args))
            logging.info(f"target={path}")
        else:
            pobj = self._run(args, env, path)
            if pobj.returncode != 0:
                if pobj.stderr is not None:
                    err = pobj.stderr.read()
                    logging.error(f"PostgreSQL {self.name} dump failed.")
                    logging.error(err.strip())


@dataclass
class MySQL(Database):
    """Dataclass for MySQL databases."""

    def build_command_args(self) -> List[str]:
        """Build cmd command arguments."""
        password = self._get_password()

        if self.ssh is None:
            args: List[str] = []
        elif password is None:
            args = ["ssh", self.ssh] + self.ssh_args
        else:
            args = ["ssh", self.ssh] + self.ssh_args + [f"MYSQL_PWD={password}"]
        args.append("mysqldump")
        args.append(f"--user={self.user}")
        if self.options is not None:
            args += self.options.split(" ")
        args.append(self.name)
        return args

    def backup(self, dry_run: bool = False):
        """Make backup."""
        env: Dict[str, str] = {}
        if self.ssh is None:
            s = self._get_password()
            if s is not None:
                env["MYSQL_PWD"] = s

        args = self.build_command_args()
        cmd = '" "'.join(
            ["MYSQL_PWD" if a.startswith("MYSQL_PWD") else a for a in args]
        )
        logging.info(f"Dumping MySQL database {self.name}.")
        logging.debug(f'Running MySQL command: "{cmd}"')

        hostname = self.ssh if self.ssh is not None else socket.gethostname()
        path = Path(hostname) / "db-dumps" / "MySQL" / self.name
        if self.target is not None:
            path = self.target / path
        path = path.absolute()
        if not path.exists() and not dry_run:
            path.mkdir(parents=True, exist_ok=True)

        path /= f"{self.name}_{timestamp()}.sql.gz"
        logging.debug(f"Storing {self.name} dump in {path}.")

        if dry_run:
            logging.info(" ".join([f"{k}={v}" for k, v in env.items()]))
            logging.info(" ".join(args))
            logging.info(f"target={path}")
        else:
            pobj = self._run(args, env, path)
            if pobj.returncode != 0:
                if pobj.stderr is not None:
                    err = pobj.stderr.read()
                    logging.error(f"MySQL {self.name} dump failed.")
                    logging.error(err.strip())


@dataclass
class Script:
    """Dataclass for scripts."""

    T = TypeVar("T", bound="Script")

    path: Path
    args: List[str]
    cwd: Optional[Path]

    @classmethod
    def from_xml(
        cls: Type[T],
        e: etree.Element,
        cwd: Optional[Path] = None,
        cmd: Union[Tuple[Tool, List[str]], List[str]] = [],
        **kwargs,
    ) -> T:
        """Create Script from XML.

        Args:
         * e: XML Element
         * cwd: path to working dir to run from
         * cmd: default list of arguments if not otherwise specified.

        Returns:
         * Instance of script.
        """
        assert isinstance(cmd, list)

        path = Path(e.find("p:command", namespaces=NAMESPACE).text.strip())
        if e.find("p:args", namespaces=NAMESPACE) is not None:
            args = shlex.split(e.find("p:args", namespaces=NAMESPACE).text.strip())
        else:
            args = cmd
        return cls(path, args, cwd)

    def build_command_args(self, dry_run: bool = False) -> List[str]:
        """Build cmd command arguments."""
        return [str(self.path)] + self.args

    def run(self, dry_run: bool = False):
        """Run."""

        def log(stream, level, writer):
            while True:
                line = stream.readline().decode()
                if line:
                    logging.log(level, line.split("\r")[-1].rstrip())
                else:
                    break

        args = self.build_command_args(dry_run)
        cmd = '" "'.join(args)
        logging.debug(f'Running: "{cmd}" with working directory {self.cwd}')

        if dry_run:
            logging.info("The following command would be run:")
            logging.info(f'"{cmd}"')
            logging.info(f"with the working directory: {self.cwd}")
        else:
            pobj = subprocess.Popen(
                args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=self.cwd
            )

            t_stdout = Thread(target=log, args=(pobj.stdout, 15, sys.stdout))
            t_stderr = Thread(target=log, args=(pobj.stderr, logging.ERROR, sys.stderr))

            t_stdout.start()
            t_stderr.start()

            while t_stdout.is_alive() and t_stderr.is_alive():
                pass
            pobj.wait()
            sleep(1)


@dataclass
class Source(Script):
    """Dataclass for sources."""

    T = TypeVar("T", bound="Source")

    tool: Tool
    target: Path
    host: Optional[str] = None
    excludes: Set[str] = field(default_factory=set)
    pre_script: Optional[Script] = None
    post_script: Optional[Script] = None

    @property
    def hostname(self) -> str:
        """Get the hostname either from self.host or from socket.gethostname.

        Returns:
         * hostname
        """
        if self.host:
            return self.host
        else:
            return socket.gethostname()

    @classmethod
    def from_xml(
        cls: Type[T],
        e: etree.Element,
        cwd: Optional[Path] = None,
        cmd: Union[Tuple[Tool, List[str]], List[str]] = [],
        **kwargs,
    ) -> T:
        """Create Script from XML.

        Args:
         * e: XML Element
         * cwd: path to working dir to run from
         * cmd: backup tool, an instance of the Tool enum.

        Returns:
         * Instance of script.
        """
        assert isinstance(cmd, tuple)

        default_target = (
            kwargs["default_target"] if "default_target" in kwargs else None
        )
        scripts = kwargs["scripts"] if "scripts" in kwargs else {}

        path = e.find("p:path", namespaces=NAMESPACE)
        host = path.attrib["host"] if "host" in path.attrib else None

        if e.find("p:target", namespaces=NAMESPACE) is not None:
            target = Path(e.find("p:target", namespaces=NAMESPACE).text.strip())
        elif default_target is not None:
            target = default_target
        else:
            logging.error(f"No target for source {path}.")
            sys.exit(1)

        source = cls(
            tool=cmd[0],
            path=Path(path.text.strip()),
            args=cmd[1],
            cwd=None,
            host=host,
            target=target,
        )

        if e.find("p:exclude", namespaces=NAMESPACE) is not None:
            excludes = set()
            for exclude in e.iterfind("p:exclude", namespaces=NAMESPACE):
                excludes.add(exclude.text.strip())
            source.excludes = excludes

        if e.find("p:pre_script", namespaces=NAMESPACE) is not None:
            source.pre_script = scripts[
                int(e.find("p:pre_script", namespaces=NAMESPACE).text.strip())
            ]
        if e.find("p:post_script", namespaces=NAMESPACE) is not None:
            source.post_script = scripts[
                int(e.find("p:post_script", namespaces=NAMESPACE).text.strip())
            ]

        return source

    def build_command_args(self, dry_run: bool = False) -> List[str]:
        """Build command line arguments."""
        if self.host:
            logging.info(f"Backup remote source {self.host}:{self.path}.")
            path = self.path
        else:
            logging.info(f"Backup local source {self.path}.")
            if self.path.is_dir():
                path = self.path
            else:
                path = self.path.parent

        target = self.target / self.hostname / "files"
        backup_dir = self.target / self.hostname / "backup"

        snapshot = None
        if self.tool == Tool.RSYNC:
            target = target / path.relative_to(target.anchor)
            backup_dir = backup_dir / path.relative_to(backup_dir.anchor)
        elif self.tool == Tool.TAR:
            target = target / path.parent.relative_to(target.anchor)
            if not target.exists() and not dry_run:
                target.mkdir(parents=True, exist_ok=True)
            snapshot = target / f"{path.name}.snapshot"
            tar_name = f"{path.name}.%d.tar"

        logging.info(f"Backup target {target}.")

        if not target.exists() and not dry_run:
            target.mkdir(parents=True, exist_ok=True)

        cmd = [self.tool.value]
        for arg in self.args:
            if self.tool == Tool.TAR:
                if arg in ["-z", "--gzip", "--gunzip", "--ungzip"]:
                    tar_name += ".gz"
                elif arg in ["-j", "--bzip2"]:
                    tar_name += ".bz2"
                elif arg in ["-J", "--xz"]:
                    tar_name += ".xz"
                elif arg == "--lzip":
                    tar_name += ".lz"
                elif arg == "--lzma":
                    tar_name += ".lzma"
                elif arg == "--lzop":
                    tar_name += ".lzo"
                elif arg in ["-Z", "--compress", "--uncompress"]:
                    tar_name += ".Z"
                elif arg == "--zstd":
                    tar_name += ".zst"

            if self.tool == Tool.RSYNC and arg == "--backup-dir=%s":
                cmd += [arg % backup_dir]
            elif self.tool == Tool.TAR and arg == "--listed-incremental=%s":
                tar_name %= len(list(target.glob(tar_name.replace("%d", "*"))))
                cmd += [arg % snapshot]
            else:
                cmd += [arg]
        for exclude in self.excludes:
            cmd += [f"--exclude={exclude}"]

        source = str(self.path)
        if self.host:
            source = f"{self.host}:{self.path}{'/' if self.tool == Tool.RSYNC else ''}"
        elif self.path.is_dir():
            source = f"{self.path}{'/' if self.tool == Tool.RSYNC else ''}"

        if self.tool == Tool.RSYNC:
            return cmd + [
                source,
                str(target.absolute()),
            ]
        elif self.tool == Tool.TAR:
            return cmd + [
                "--file",
                str((target / tar_name).absolute()),
                source,
            ]
        else:
            return []

    def backup(self, dry_run: bool = False):
        """Make backup."""
        if self.pre_script is not None:
            logging.info(f"Run pre-script {self.pre_script.path}.")
            self.pre_script.run(dry_run)
        self.run(dry_run)
        if self.post_script is not None:
            logging.info(f"Run post-script {self.post_script.path}.")
            self.post_script.run(dry_run)


def to_bool(string: str, default: bool = False) -> bool:
    """Convert string to bool.

    Args:
     * string: string to convert
     * default: default boolean if no match

    Returns:
     * boolean value
    """
    if string == "1" or string == "yes" or string == "true" or string == "on":
        return True
    elif string == "0" or string == "no" or string == "false" or string == "off":
        return False
    else:
        return default


def timestamp() -> str:
    """Get current timestamp as string.

    Returns:
     * current timestamp in the format of "%Y%m%dT%H%M%S%z"
    """
    return time.strftime("%Y%m%dT%H%M%S%z", time.localtime())


def load(
    path: Union[Path, TextIO], schema_path: str = "/usr/share/backup/backup.xsd"
) -> Optional[etree.ElementTree]:
    """Load XML and check validity.

    Args:
     * path: path to XML file

    Returns:
     * XML as etree.ElementTree if valid otherwise None
    """
    if not Path(schema_path).exists():
        schema_path = "./backup.xsd"
    logging.debug(
        f'Loading XML file "{path if isinstance(path, Path) else path.name}".'
    )
    doc = etree.parse(str(path.absolute()) if isinstance(path, Path) else path)

    logging.debug(f'Loading XML schema "{schema_path}".')
    xmlschema = etree.XMLSchema(etree.parse(schema_path))

    if not xmlschema.validate(doc):
        logging.error(
            f"XML file {path if isinstance(path, Path) else path.name} is not valid."
        )
        logging.error(xmlschema.error_log.last_error)
        return None
    else:
        logging.debug(
            f"XML file {path if isinstance(path, Path) else path.name} is valid."
        )
        return doc


def parse(
    path: Union[Path, TextIO],
    target: Optional[Path] = None,
    default_tool: Optional[Tool] = None,
    default_config: Optional[List[str]] = None,
) -> Tuple[
    Dict[int, str], List[Source], List[MySQL], List[PostgreSQL], Dict[int, Script]
]:
    """Parse XML file.

    Args:
     * path: path to XML file to parse
     * target: optional target to use as default target
    """
    assert (default_tool is None and default_config is None) or (
        default_tool is not None and default_config is not None
    )

    doc = load(path)
    if doc is None:
        sys.exit(1)

    if default_tool is None and default_config is None:
        e = doc.find("p:tool", namespaces=NAMESPACE)
        tool = Tool(e.attrib["name"].strip())
        config = shlex.split(e.text.strip()) if e.text else []
    if default_tool is not None:
        tool = default_tool
    if default_config is not None:
        config = default_config

    if (
        target is None
        and doc.find("p:options/p:target", namespaces=NAMESPACE) is not None
    ):
        target = Path(doc.find("p:options/p:target", namespaces=NAMESPACE).text.strip())

    mysqls: List[MySQL] = []
    for e in doc.xpath("p:databases/p:mysql/*", namespaces=NAMESPACE):
        mysqls.append(MySQL.from_xml(e, target))

    pgsqls: List[PostgreSQL] = []
    for e in doc.xpath("p:databases/p:postgresql/*", namespaces=NAMESPACE):
        pgsqls.append(PostgreSQL.from_xml(e, target))

    scripts: Dict[int, Script] = {}
    for e in doc.xpath("p:scripts/p:script", namespaces=NAMESPACE):
        scripts[int(e.attrib["id"].strip())] = Script.from_xml(e)

    sources: List[Source] = []
    for e in doc.xpath("p:sources/p:source", namespaces=NAMESPACE):
        sources.append(
            Source.from_xml(
                e,
                cmd=(tool, config),
                default_target=target,
                scripts=scripts,
            )
        )

    pipeline: Dict[int, str] = {}
    for step in doc.xpath("p:pipeline/*", namespaces=NAMESPACE):
        pipeline[int(step.attrib["no"].strip())] = step.text.strip()

    for e in doc.xpath("p:sources/p:file", namespaces=NAMESPACE) + doc.xpath(
        "p:databases/p:file", namespaces=NAMESPACE
    ):
        npath = Path(e.text.strip())
        if not npath.is_absolute():
            if isinstance(path, Path):
                npath = path.parent / npath
            else:
                npath = Path(path.name).parent / npath
        values = parse(
            npath,
            target,
            default_tool=tool,
            default_config=config,
        )
        sources += values[1]
        mysqls += values[2]
        pgsqls += values[3]

    return pipeline, sources, mysqls, pgsqls, scripts


def snapshot(sources: List[Source]):
    """Make a snapshot of a list of Sources and stores it in a tar.gz.

    Args:
     * sources: list of sources to include in the snapshot
    """
    base_dirs: Set[Path] = set()
    for source in sources:
        base_dirs.add(source.target / source.hostname)

    for base_dir in base_dirs:
        logging.info(f"Taking snapshot of: {base_dir}")

        snapshot_dir = base_dir / "snapshots"
        if not snapshot_dir.exists():
            snapshot_dir.mkdir(parents=True, exist_ok=True)
        snapshot_dir /= f"{timestamp()}.tar.gz"
        files_dir = base_dir / "files"
        tar = Script(
            path=Path("tar"),
            args=[
                "-czf",
                str(snapshot_dir),
            ]
            + [file.name for file in files_dir.iterdir()],
            cwd=files_dir,
        )
        tar.run()


if __name__ == "__main__":
    parser = ArgumentParser(prog="backup", formatter_class=ArgFormatter)
    parser.add_argument(
        "-V",
        "--version",
        action="version",
        version=VERSION,
    )
    parser.add_argument(
        "--is-valid",
        action="store_true",
        dest="check_valid",
        help="checks the given XML file validity.",
    )
    parser.add_argument(
        "-d",
        "--no-database",
        action="store_true",
        dest="database",
        help="disable database dumps.",
    )
    parser.add_argument(
        "-p",
        "--no-postgres",
        action="store_true",
        dest="postgres",
        help="disables PostgreSQL dumps.",
    )
    parser.add_argument(
        "-m",
        "--no-mysql",
        action="store_true",
        dest="mysql",
        help="disables MySQL dumps.",
    )
    parser.add_argument(
        "-s",
        "--snapshot",
        action="store_true",
        dest="snapshot",
        help="make a snapshot, as tar.gz.",
    )
    parser.add_argument(
        "-S",
        "--snapshot-only",
        action="store_true",
        dest="snapshot_only",
        help="only make a snapshot, as tar.gz.",
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help="verbosity level; multiple times increases the level, the maximum is 3, "
        + "for debugging.",
    )
    parser.add_argument(
        "-f",
        "--log-format",
        default="%(message)s",
        help="set logging format.",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="do a dry run.",
    )
    parser.add_argument(
        "XML",
        type=FileType("r", encoding="utf8"),
        default=sys.stdout,
        help="XML config file.",
    )
    parser.add_argument(
        "TARGET",
        nargs="?",
        type=lambda p: Path(p).absolute(),
        help="optional backup target, will override target defined in XML config.",
    )
    args = parser.parse_args()

    if args.verbose == 0:
        level = logging.WARN
    elif args.verbose == 1:
        level = logging.INFO
    elif args.verbose == 2:
        level = 15
    else:
        level = logging.DEBUG

    logging.basicConfig(
        format=args.log_format,
        level=level,
        handlers=[logging.StreamHandler(sys.stdout)],
    )

    pipeline: Dict[int, str] = {}
    if args.XML is not None:
        if args.check_valid:
            if load(args.XML) is not None:
                logging.info(f"XML file {args.XML.name} is valid.")
                sys.exit(0)
            else:
                sys.exit(1)
        else:
            if args.TARGET:
                logging.info(f"Using '{args.TARGET}' as backup target.")
                if not args.TARGET.exists():
                    logging.error("The given target path does not exists.")
                    if not args.dry_run:
                        sys.exit(1)

            pipeline, sources, mysqls, pgsqls, scripts = parse(args.XML, args.TARGET)
    else:
        parser.print_usage()

    if not args.snapshot_only:
        for k, v in sorted(pipeline.items(), key=lambda x: x[0]):
            if v == "backup":
                for source in sources:
                    source.backup(args.dry_run)
            elif v == "postgresql-dbs" and not (args.postgres or args.database):
                for pgsql in pgsqls:
                    pgsql.backup(args.dry_run)
            elif v == "mysql-dbs" and not (args.mysql or args.database):
                for mysql in mysqls:
                    mysql.backup(args.dry_run)
            elif v.startswith("script-"):
                logging.info(f"Running script {scripts[int(v[7:])].path}.")
                scripts[int(v[7:])].run(args.dry_run)

    if args.snapshot or args.snapshot_only:
        snapshot(sources)

    logging.info("Backup complete.")
