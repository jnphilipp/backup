#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Python wrapper for rsync to easily configure rsync.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
import re
import socket
import sys
import time

import gi
gi.require_version('Notify', '0.7')

from argparse import ArgumentParser, RawTextHelpFormatter, ArgumentTypeError
from gi.repository import Notify
from lxml import etree
from math import ceil, floor
from subprocess import Popen, PIPE, call


__author__ = 'jnphilipp'
__email__ = 'mail@jnphilipp.org'
__license__ = 'GPLv3'
__version__ = '0.1.4'
__github__ = 'https://github.com/jnphilipp/psync'
__app__ = (('###########################################\n' +
            '#                  psync                  #\n' +
            '#           python rsync wrapper          #\n' +
            '#                                         #\n' +
            '#%s%s%s#\n' % (' ' * floor((40 - len(__version__)) / 2),
                            'v%s' % __version__,
                            ' ' * ceil((40 - len(__version__)) / 2)) +
            '#%s%s%s#\n' % (' ' * floor((41 - len(__license__)) / 2),
                            __license__,
                            ' ' * ceil((41 - len(__license__)) / 2)) +
            '#                                         #\n' +
            '#%s%s%s#\n' % (' ' * floor((41 - len(__author__)) / 2), __author__,
                            ' ' * ceil((41 - len(__author__)) / 2)) +
            '#%s%s%s#\n' % (' ' * floor((41 - len(__email__)) / 2), __email__,
                            ' ' * ceil((41 - len(__email__)) / 2)) +
            '#                                         #\n' +
            '#%s%s%s#\n' % (' ' * floor((41 - len(__github__)) / 2), __github__,
                            ' ' * ceil((41 - len(__github__)) / 2)) +
            '###########################################'))


NAMESPACE = {'p': 'http://jnphilipp.org/psync/'}
BOOLEAN_STATES = {
    '1': True,
    'yes': True,
    'true': True,
    'on': True,
    '0': False,
    'no': False,
    'false': False,
    'off': False
}


def get_boolean(string, default=False):
    return BOOLEAN_STATES[string] if string in BOOLEAN_STATES else default


def send_notification(message):
    """send messages to notify-osd"""
    try:
        notification = Notify.Notification.new('psync', message, 'deja-dup')
        notification.show()
    except:
        print(message)


def load(path):
    if not os.path.exists(path):
        print('xml file "%s" not found. aborting...' % path)
        sys.exit(1)
    return etree.parse(path)


def check_valid(path, doc):
    xmlschema = etree.XMLSchema(etree.parse('/usr/share/psync/psync.xsd'))
    if not xmlschema.validate(doc):
        print('xml file "%s" not valid. aborting...' % path)
        xmlschema.assertValid(doc)
        sys.exit(1)


def parse(path, target=None):
    doc = load(path)
    check_valid(path, doc)

    options = {
        'target': None,
        'git': True,
        'git_root': False,
        'rsync_root': False
    }
    if doc.find('p:options/p:git', namespaces=NAMESPACE) is not None:
        o = doc.find('p:options/p:git', namespaces=NAMESPACE)
        options['git'] = get_boolean(o.text.strip(), True)
        if 'root' in o.attrib:
            options['git_root'] = get_boolean(o.attrib['root'].strip(), True)
    if doc.find('p:options/p:rsync', namespaces=NAMESPACE) is not None:
        o = doc.find('p:options/p:rsync', namespaces=NAMESPACE)
        options['rsync'] = o.text.strip()
        if 'root' in o.attrib:
            options['rsync_root'] = get_boolean(o.attrib['root'].strip(), False)
    if doc.find('p:options/p:target', namespaces=NAMESPACE) is not None:
        options['target'] = doc.find('p:options/p:target',
                                     namespaces=NAMESPACE).text.strip()
    if doc.find('p:options/p:pre_backup_script',
                namespaces=NAMESPACE) is not None:
        options['pre_backup_script'] = doc.find('p:options/p:pre_backup_script',
                                                namespaces=NAMESPACE).text.strip()
    if doc.find('p:options/p:post_backup_script',
                namespaces=NAMESPACE) is not None:
        options['post_backup_script'] = doc.find('p:options/p:post_backup_script',
                                                 namespaces=NAMESPACE).text.strip()

    if target:
        options['target'] = target

    pipeline = {}
    for step in doc.xpath('p:pipeline/*', namespaces=NAMESPACE):
        step_no = int(step.attrib['no'].strip())
        pipeline[step_no] = step.text.strip()
        if pipeline[step_no] == 'backup' and not options['target']:
            print('No target provided. aborting...')
            sys.exit(1)

    sources, mysqls, pgsqls = parse_sources(doc, options['target'])
    pgsqls += parse_dbs(doc.xpath('p:databases/p:postgresql/*',
                                  namespaces=NAMESPACE))
    mysqls += parse_dbs(doc.xpath('p:databases/p:mysql/*',
                                  namespaces=NAMESPACE))
    parse_db_files(doc.xpath('p:databases/p:file',
                             namespaces=NAMESPACE), mysqls, pgsqls)
    return options, sources, mysqls, pgsqls, pipeline


def parse_sources(doc, target):
    sources = []
    mysqls = []
    pgsqls = []
    for s in doc.xpath('p:sources/p:source', namespaces=NAMESPACE):
        source = {
            'path': s.find('p:path', namespaces=NAMESPACE).text.strip()
        }
        if s.find('p:exclude', namespaces=NAMESPACE) is not None:
            source['exclude'] = []
            for e in s.iterfind('p:exclude', namespaces=NAMESPACE):
                source['exclude'].append(e.text.strip())
        if s.find('p:target', namespaces=NAMESPACE) is not None:
            source['target'] = s.find('p:target',
                                      namespaces=NAMESPACE).text.strip()
        if s.find('p:rsync', namespaces=NAMESPACE) is not None:
            o = s.find('p:rsync', namespaces=NAMESPACE)
            source['rsync'] = o.text.strip()
            if 'root' in o.attrib:
                source['root'] = get_boolean(o.attrib['root'].strip(), False)
        if s.find('p:post_script', namespaces=NAMESPACE) is not None:
            source['post_script'] = s.find('p:post_script',
                                           namespaces=NAMESPACE).text.strip()
        sources.append(source)

    for f in doc.xpath('p:sources/p:file', namespaces=NAMESPACE):
        options, fsources, fmysqls, fpgsqls, _ = parse(f.text.strip(), target)
        for fsource in fsources:
            fsource['root'] = options['rsync_root']
            if 'rsync' in options:
                fsource['rsync'] = options['rsync']
        if 'root' in f.attrib:
            for fsource in fsources:
                fsource['root'] = get_boolean(f.attrib['root'], False)
        sources += fsources
        mysqls += fmysqls
        pgsqls += fpgsqls
    return sources, mysqls, pgsqls


def parse_db_files(file_iter, mysqls, pgsqls):
    for f in file_iter:
        path = f.text.strip()
        doc = load(path)
        check_valid(path, doc)
        pgsqls += (parse_dbs(doc.xpath('p:databases/p:postgresql/*',
                                       namespaces=NAMESPACE)))
        mysqls += (parse_dbs(doc.xpath('p:databases/p:mysql/*',
                                       namespaces=NAMESPACE)))
        parse_db_files(doc.xpath('p:databases/p:file',
                                 namespaces=NAMESPACE), mysqls, pgsqls)


def parse_dbs(db_iter):
    dbs = []
    for c in db_iter:
        db = {
            'name': c.find('p:name', namespaces=NAMESPACE).text.strip(),
            'user': c.find('p:user', namespaces=NAMESPACE).text.strip()
        }
        if c.find('p:password', namespaces=NAMESPACE) is not None:
            db['password'] = c.find('p:password',
                                    namespaces=NAMESPACE).text.strip()
        if c.find('p:pass', namespaces=NAMESPACE) is not None:
            db['pass'] = c.find('p:pass',
                                namespaces=NAMESPACE).text.strip()
        if c.find('p:target', namespaces=NAMESPACE) is not None:
            db['target'] = c.find('p:target',
                                  namespaces=NAMESPACE).text.strip()
        if c.find('p:options', namespaces=NAMESPACE) is not None:
            db['options'] = c.find('p:options',
                                   namespaces=NAMESPACE).text.strip()
        if c.find('p:ssh', namespaces=NAMESPACE) is not None:
            db['ssh'] = c.find('p:ssh',
                               namespaces=NAMESPACE).text.strip()
        dbs.append(db)
    return dbs


def backup(options, sources, snapshot):
    print('-' * 100)

    base_dirs = {}
    timestamp = time.strftime('%Y%m%dT%H%M%S%z', time.localtime())
    for source in sources:
        send_notification('Starting backup of "%s".' % source['path'])
        print('Backup of: %s' % source['path'])

        exclude = ''
        if 'exclude' in source:
            exclude = ' '.join('--exclude="%s"' % e for e in source['exclude'])

        if 'rsync' in source:
            rsync_config = source['rsync']
        else:
            rsync_config = options['rsync']

        if 'target' in source:
            target = source['target']
        else:
            target = options['target']

        if 'root' in source:
            rsync_root = source['root']
        else:
            rsync_root = options['rsync_root']

        match = re.match(r'^([^/]+@)?[^/]+:', source['path'])
        if match:
            print('Is remote: %s' % source['path'])
            hostname = match.group(0)[:-1]
            target_dir = '/%s' % re.sub(r'^([^/]+@)?[^/]+:',
                                        '%s/%%s' % hostname, source['path'])
        else:
            hostname = socket.gethostname()
            if os.path.isdir(source['path']):
                path = source['path']
            else:
                path = os.path.dirname(source['path'])
            target_dir = '/%s/%%s%s' % (hostname, path)
        base_dir = '%s/%s' % (target, hostname)
        if base_dir not in base_dirs:
            base_dirs[base_dir] = False
        base_dirs[base_dir] += rsync_root
        current_backup_dir = '%s%s' % (target, target_dir % 'backup')
        target += target_dir % 'files'

        if '--backup-dir=%s' in rsync_config:
            if ' ' in current_backup_dir:
                print('The --backup-dir has whitespaces in it "%s",' +
                      ' removing it.' % current_backup_dir)
                rsync_config = rsync_config.replace('--backup-dir=%s', '')
            else:
                rsync_config = rsync_config % ('"%s"' % current_backup_dir)

        if not os.path.exists(target):
            os.makedirs(target)
        target = '"%s"' % target

        if os.path.isdir(source['path']):
            path = '%s/' % source['path']
        else:
            path = source['path']
        rsync = '%srsync %s %s %s %s' % ('sudo ' if rsync_root else '',
                                         exclude, rsync_config, path, target)
        print(rsync)
        p = Popen(rsync, stdout=PIPE, stderr=PIPE, shell=True)

        out = ''
        while p.poll() is None:
            line = p.stdout.readline().decode('utf-8')
            out += line.split('\r')[-1]
            sys.stdout.write(line)
            sys.stdout.flush()
        err = ('\n%s' % p.communicate()[1].decode('utf-8')).strip()
        print()
        print('-' * 100)
        print('rsync errors\n%s' % err)
        _write_logfile(base_dir, timestamp, rsync, out, err)

        if 'post_script' in source:
            print('-' * 100)
            send_notification('Start post script "%s".' % source['post_script'])
            print('Start post script "%s".' % source['post_script'])
            os.system(source['post_script'])
        print('-' * 100)

    if options['git']:
        timestamp = time.strftime('%Y-%m-%dT%H:%M:%S%z', time.localtime())
        for base_dir in base_dirs.keys():
            print('Commit changes in "%s"' % base_dir)
            os.chdir('%s/files' % base_dir)

            if options['git_root'] and not os.system('sudo git rev-parse') == 0:
                os.system('sudo git init')
            elif not options['git_root'] and not os.system('git rev-parse') == 0:
                os.system('git init')

            if os.path.exists('.gitmodules'):
                _delete_gitmodules(options['git_root'])

            gits = _find_gits(options['git_root'])
            if gits:
                _write_gitmodules(gits)
            else:
                if os.path.exists('.gitmodules'):
                    os.remove('.gitmodules')

            git_add = 'git add -A'
            git_commit = 'git commit -m "Backup from %s."' % timestamp
            if options['git_root']:
                os.system('sudo %s' % git_add)
                os.system('sudo %s' % git_commit)
            else:
                os.system(git_add)
                os.system(git_commit)
            print('-' * 100)

    if snapshot:
        t = time.localtime()
        timestamp = time.strftime('%Y%m%dT%H%M%S%z', t)
        for base_dir, root in base_dirs.items():
            send_notification('Taking snapshot of "%s".' % base_dir)
            print('Taking snapshot of: "%s"' % base_dir)

            if not os.path.exists('%s/snapshots' % base_dir):
                os.makedirs('%s/snapshots' % base_dir)
            os.chdir('%s/files' % base_dir)
            if options['git']:
                msg = time.strftime('Snapshot from %d. %B %Y %H:%M:%S%z.', t)
                git_tag = "git tag -a v%s -m '%s'" % (timestamp, msg)
                if options['git_root']:
                    os.system('sudo %s' % git_tag)
                else:
                    os.system(git_tag)
            tar = 'tar -czf ../snapshots/%s.tar.gz *' % timestamp
            if _has_hidden_files(base_dir):
                tar += ' .??*'
            print("%s%s" % ('sudo ' if root else '', tar))
            os.system("%s%s" % ('sudo ' if root else '', tar))
            print('-' * 100)


def run_script(script):
    print('-' * 100)
    send_notification('Start script "%s".' % script)
    print('Starting script "%s".' % script)
    call(script, shell=True)
    print('-' * 100)


def postgres_dump(options, pgsqls):
    print('-' * 100)
    print('Start dumping of PostgreSQL databases.')
    send_notification('Start dumping of PostgreSQL databases.')

    timestamp = time.strftime('%Y%m%dT%H%M%S%z', time.localtime())
    for db in pgsqls:
        print('Backup of: "%s"' % db['name'])
        if 'target' in db:
            path = db['target']
        else:
            hostname = db['ssh'] if 'ssh' in db else socket.gethostname()
            path = '%s/%s/db-dumps/PostgreSQL/%s' % (options['target'],
                                                     hostname, db['name'])

        if not os.path.exists(path):
            os.makedirs(path)
        path = '"%s"' % path

        command = 'ssh %s ' % db['ssh'] if 'ssh' in db else ''
        if 'pass' in db:
            command += 'PGPASSWORD="%s"' % _pass(db['pass'])
        elif 'password' in db:
            command += 'PGPASSWORD="%s"' % db['password']
        else:
            command += ''

        command += ' pg_dump --username=%s' % db['user']
        if 'options' in db:
            command += ' %s' % db['options']
        path = os.path.join(path, '%s_%s.sql.gz' % (db['name'], timestamp))
        command += ' %s | gzip -c > %s' % (db['name'], path)
        os.system(command)
    print('-' * 100)


def mysql_dump(options, mysqls):
    print('-' * 100)
    print('Start dumping of MySQL databases.')
    send_notification('Start dumping of MySQL databases.')

    timestamp = time.strftime('%Y%m%dT%H%M%S%z', time.localtime())
    for db in mysqls:
        print('Backup of: "%s"' % db['name'])
        if 'target' in db:
            path = db['target']
        else:
            hostname = db['ssh'] if 'ssh' in db else socket.gethostname()
            path = '%s/%s/db-dumps/MySQL/%s' % (options['target'], hostname,
                                                db['name'])

        if not os.path.exists(path):
            os.makedirs(path)
        path = '"%s"' % path

        command = 'ssh %s ' % db['ssh'] if 'ssh' in db else ''
        command += 'mysqldump --user=%s' % db['user']
        if 'pass' in db:
            command += ' --password=%s' % _pass(db['pass'])
        elif 'password' in db:
            command += ' --password=%s' % db['password']
        else:
            command += ''

        if 'options' in db:
            command += ' %s' % db['options']
        path = os.path.join(path, '%s_%s.sql.gz' % (db['name'], timestamp))
        command += ' %s | gzip -c > %s' % (db['name'], path)
        os.system(command)
    print('-' * 100)


def _delete_gitmodules(root=False):
    print('-' * 100)
    print('Deleting gitmodules')
    with open('.gitmodules', 'r') as f:
        for line in f:
            if line.startswith('    path = '):
                git_rm = 'git rm -r --cached "%s"' & line[11:].strip()
                call('%s%s' % ('sudo ' if root else '', git_rm), shell=True)


def _write_gitmodules(submodules):
    print('Writing gitmodules')
    with open('.gitmodules', 'w') as f:
        for submodule in submodules.split('\n'):
            f.write('[submodule "%s"]\n' % os.path.basename(submodule))
            f.write('    path = %s\n' % submodule)
    print('-' * 100)


def _find_gits(root=False):
    command = ('find . -type d \( -exec /usr/bin/test -d "{}/.git" -a ' +
               '"{}" != "." \; -print -prune -o -name .git -prune \)')
    p = Popen('sudo %s' % command if root else command, stdout=PIPE, shell=True)
    return p.communicate()[0].decode('utf-8').strip()


def _pass(path):
    if path:
        p = Popen('pass %s' % path, stdout=PIPE, shell=True)
        return p.communicate()[0].decode('utf-8').split('\n')[0]
    else:
        return ''


def _has_hidden_files(path):
    if path:
        p = Popen('ls -A | grep "^\." | wc -l', stdout=PIPE, shell=True)
        return int(p.communicate()[0].decode('utf-8').split('\n')[0]) != 0
    else:
        return False


def _write_logfile(base_dir, timestamp, rsync, out, err):
    log_dir = os.path.join(base_dir, 'log')
    if not os.path.exists(log_dir):
        os.makedirs(log_dir)

    log_file = os.path.join(log_dir, '%s.log' % timestamp)
    with open(log_file, 'a', encoding='utf-8') as f:
        f.write('%s\n' % ('-' * 100))
        f.write('%s\n' % rsync)
        f.write('%s\n' % ('-' * 100))
        f.write('%s\n' % out)
        f.write('%s\n' % ('-' * 100))
        f.write('%s\n' % err)
        f.write('%s\n' % ('-' * 100))


if __name__ == '__main__':
    Notify.init('psync')

    parser = ArgumentParser(prog='psync', formatter_class=RawTextHelpFormatter)
    parser.add_argument('-v', '--version', action='version', version=__app__)
    parser.add_argument('-t', '--target', help='Backup target')
    parser.add_argument('-x', '--xml', dest='xml', help='XML config file')
    parser.add_argument('--is-valid', action='store_true', dest='check_valid',
                        help='checks the given xml file on valid')
    parser.add_argument('-d', '--no-database', action='store_true',
                        dest='database', help='Disables database dumps')
    parser.add_argument('-p', '--no-postgres', action='store_true',
                        dest='postgres', help='Disables PostgreSQL dumps')
    parser.add_argument('-m', '--no-mysql', action='store_true',
                        dest='mysql', help='Disables MySQL dumps')
    parser.add_argument('-s', '--snapshot', action='store_true',
                        dest='snapshot', help='Make a snapshot')
    args = parser.parse_args()

    pipeline = {}
    if args.xml is not None:
        if args.check_valid:
            check_valid(args.xml, load(args.xml))
            print('XML file "%s" is valid.' % args.xml)
            sys.exit(0)
        else:
            options, sources, mysqls, pgsqls, pipeline = parse(args.xml,
                                                               args.target)
    else:
        parser.print_usage()

    for k, v in sorted(pipeline.items()):
        if v == 'backup':
            backup(options, sources, args.snapshot)
        elif v == 'db_dump' and not args.database:
            if not args.mysql:
                mysql_dump(options, mysqls)
            if not args.postgres:
                postgres_dump(options, pgsqls)
        elif v == 'postgres_dump' and not (args.postgres or args.database):
            postgres_dump(options, pgsqls)
        elif v == 'mysql_dump' and not (args.mysql or args.database):
            mysql_dump(options, mysqls)
        elif v == 'pre_backup_script':
            run_script(options['pre_backup_script'])
        elif v == 'post_backup_script':
            run_script(options['pre_backup_script'])
