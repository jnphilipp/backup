#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
import re
import socket
import subprocess
import sys
import time

from gi.repository import Notify
from lxml import etree
from optparse import OptionParser

NAMESPACE = {'p':'http://jnphilipp.org/psync/'}
BOOLEAN_STATES = {'1':True, 'yes':True, 'true':True, 'on':True,
                    '0':False, 'no':False, 'false':False, 'off':False}

def get_boolean(string, default=False):
    return BOOLEAN_STATES[string] if string in BOOLEAN_STATES else default

def send_notification(message):
    """send messages to notify-osd"""
    try:
        notification = Notify.Notification.new('psync', message, 'deja-dup')
        notification.show()
    except:
        print(message)

def load(path):
    if not os.path.exists(path):
        print('xml file "%s" not found. aborting...' % path)
        sys.exit(1)
    return etree.parse(path)

def check_valid(path, doc):
    xmlschema = etree.XMLSchema(etree.parse('/usr/share/psync/psync.xsd'))
    if not xmlschema.validate(doc):
        print('xml file "%s" not valid. aborting...' % path)
        xmlschema.assertValid(doc)
        sys.exit(1)

def parse(path, target=None):
    doc = load(path)
    check_valid(path, doc)

    options = {'target':None, 'git':True, 'git_root':False, 'rsync_root':False}
    if doc.find('p:options/p:git', namespaces=NAMESPACE) is not None:
        o = doc.find('p:options/p:git', namespaces=NAMESPACE)
        options['git'] = get_boolean(o.text.strip(), True)
        if 'root' in o.attrib:
            options['git_root'] = get_boolean(o.attrib['root'].strip(), True)
    if doc.find('p:options/p:rsync', namespaces=NAMESPACE) is not None:
        o = doc.find('p:options/p:rsync', namespaces=NAMESPACE)
        options['rsync'] = o.text.strip()
        if 'root' in o.attrib:
            options['rsync_root'] = get_boolean(o.attrib['root'].strip(), False)
    if doc.find('p:options/p:target', namespaces=NAMESPACE) is not None:
        options['target'] = doc.find('p:options/p:target',
                                        namespaces=NAMESPACE).text.strip()
    if doc.find('p:options/p:pre_backup_script',
                namespaces=NAMESPACE) is not None:
        options['pre_backup_script'] = doc.find('p:options/p:pre_backup_script',
                                            namespaces=NAMESPACE).text.strip()
    if doc.find('p:options/p:post_backup_script',
                namespaces=NAMESPACE) is not None:
        options['post_backup_script'] = doc.find('p:options/p:post_backup_script',
                                            namespaces=NAMESPACE).text.strip()

    if target:
        options['target'] = target

    pipeline = {}
    for step in doc.xpath('p:pipeline/*', namespaces=NAMESPACE):
        pipeline[int(step.attrib['no'].strip())] = step.text.strip()
        if pipeline[int(step.attrib['no'].strip())] == 'backup' and \
                not options['target']:
          print('no target provided. aborting...')
          sys.exit(1)

    sources = parse_sources(doc)
    pgsqls = parse_dbs(doc.xpath('p:databases/p:postgresql/*',
                                namespaces=NAMESPACE))
    mysqls = parse_dbs(doc.xpath('p:databases/p:mysql/*',
                                namespaces=NAMESPACE))
    parse_db_files(doc.xpath('p:databases/p:file',
                            namespaces=NAMESPACE), mysqls, pgsqls)
    return (options, sources, mysqls, pgsqls, pipeline)

def parse_sources(doc):
    sources = []
    for s in doc.xpath('p:sources/p:source', namespaces=NAMESPACE):
        source = {'source': s.find('p:path', namespaces=NAMESPACE).text.strip()}
        if s.find('p:exclude', namespaces=NAMESPACE) is not None:
            source['exclude'] = [e.text.strip() for e in s.iterfind('p:exclude',
                                    namespaces=NAMESPACE)]
        if s.find('p:target', namespaces=NAMESPACE) is not None:
            source['target'] = s.find('p:target',
                                        namespaces=NAMESPACE).text.strip()
        if s.find('p:rsync', namespaces=NAMESPACE) is not None:
            o = s.find('p:rsync', namespaces=NAMESPACE)
            source['rsync'] = o.text.strip()
            if 'root' in o.attrib:
                source['root'] = get_boolean(o.attrib['root'].strip(), False)
        if s.find('p:post_script', namespaces=NAMESPACE) is not None:
            source['post_script'] = s.find('p:post_script',
                                            namespaces=NAMESPACE).text.strip()
        sources.append(source)

    for f in doc.xpath('p:sources/p:file', namespaces=NAMESPACE):
        fdoc = load(f.text.strip())
        check_valid(f.text.strip(), fdoc)
        s = parse_sources(fdoc)
        if 'root' in f.attrib:
            for i in s: i['root'] = get_boolean(f.attrib['root'], False)
        sources += s
    return sources


def parse_db_files(file_iter, mysqls, pgsqls):
    for f in file_iter:
        path = f.text.strip()
        doc = load(path)
        check_valid(path, doc)
        pgsqls += (parse_dbs(doc.xpath('p:databases/p:postgresql/*',
                                namespaces=NAMESPACE)))
        mysqls += (parse_dbs(doc.xpath('p:databases/p:mysql/*',
                                namespaces=NAMESPACE)))
        parse_db_files(doc.xpath('p:databases/p:file',
                                namespaces=NAMESPACE), mysqls, pgsqls)

def parse_dbs(db_iter):
    dbs = []
    for c in db_iter:
        db = {'name': c.find('p:name', namespaces=NAMESPACE).text.strip(),
                'user': c.find('p:user', namespaces=NAMESPACE).text.strip()}
        if c.find('p:password', namespaces=NAMESPACE) is not None:
            db['password'] = c.find('p:password',
                                        namespaces=NAMESPACE).text.strip()
        if c.find('p:pass', namespaces=NAMESPACE) is not None:
            db['pass'] = c.find('p:pass', namespaces=NAMESPACE).text.strip()
        if c.find('p:target', namespaces=NAMESPACE) is not None:
            db['target'] = c.find('p:target',
                                    namespaces=NAMESPACE).text.strip()
        if c.find('p:options', namespaces=NAMESPACE) is not None:
            db['options'] = c.find('p:options',
                                    namespaces=NAMESPACE).text.strip()
        if c.find('p:ssh', namespaces=NAMESPACE) is not None:
            db['ssh'] = c.find('p:ssh', namespaces=NAMESPACE).text.strip()
        dbs.append(db)
    return dbs

def backup(options, sources, snapshot, root_snapshot):
    print('--------------------------------------------------------------------------------')
    hostname = socket.gethostname()

    base_dirs = set()
    for source in sources:
        send_notification('starting backup of "%s".' % source['source'])
        print('backup of: %s' % source['source'])

        exclude = ''
        if 'exclude' in source:
            print('excluding: %s' % ' '.join('"%s"' % exclude \
                                            for exclude in source['exclude']))
            exclude = ' '.join('--exclude="%s"' % exclude \
                                            for exclude in source['exclude'])
        current_rsync = source['rsync'] if 'rsync' in source else options['rsync']
        current_target = source['target'] \
                                if 'target' in source else options['target']
        rsync_root = source['root'] if 'root' in source else options['rsync_root']

        match = re.match(r'^([^/]+@)?[^/]+:', source['source'])
        if match:
            print('is remote: %s' % source['source'])
            base_dirs.add('%s/%s' % (current_target, match.group(0)[:-1]))
            current_target += '/%s' % re.sub(r'^([^/]+@)?[^/]+:',
                            '%s/Files' % match.group(0)[:-1], source['source'])
        else:
            base_dirs.add('%s/%s' % (current_target, hostname))
            current_target += '/%s/Files%s' % (hostname, source['source'] \
                                        if os.path.isdir(source['source']) \
                                        else os.path.dirname(source['source']))

        if not os.path.exists(current_target):
            os.makedirs(current_target)

        rsync = '%srsync %s %s %s %s' % ('sudo ' if rsync_root else '',
                                        exclude,
                                        current_rsync,
                                        '%s/' % source['source'] \
                                        if os.path.isdir(source['source']) \
                                        else source['source'], current_target)
        print(rsync)
        os.system(rsync)

        if 'post_script' in source:
            print('--------------------------------------------------------------------------------')
            send_notification('start post script "%s".' % source['post_script'])
            print('start post script "%s".'  % source['post_script'])
            os.system(source['post_script'])
        print('--------------------------------------------------------------------------------')

    if options['git']:
        timestamp = time.strftime('%Y-%m-%dT%H:%M:%S%z', time.localtime())
        for base_dir in base_dirs:
            print('commit changes in "%s"' % base_dir)
            os.chdir('%s/Files' % base_dir)
            if not os.system('git rev-parse') == 0:
                os.system('git init')

            proc = subprocess.Popen('find * -name .git -type d -prune | xargs -I{} dirname {}', stdout=subprocess.PIPE, shell=True)
            (out, err) = proc.communicate()
            with open('.gitmodules', 'w') as f:
                for submodule in out.decode('utf-8').strip().split('\n'):
                    f.write('[submodule "%s"]\n' % os.path.basename(submodule))
                    f.write('    path = %s\n' % submodule)
            f.close()

            os.system('%sgit add -A' % ('sudo ' if options['git_root'] else ''))
            os.system("%sgit commit -m 'backup from %s.'" % ('sudo ' \
                            if options['git_root'] else '', timestamp))
            print('--------------------------------------------------------------------------------')

    if snapshot or root_snapshot:
        t = time.localtime()
        timestamp = time.strftime('%Y%m%dT%H%M%S%z', t)
        for base_dir in base_dirs:
            send_notification('taking snapshot of "%s".' % base_dir)
            print('taking snapshot of: "%s"' % base_dir)

            if not os.path.exists('%s/Snapshots' % base_dir):
                os.makedirs('%s/Snapshots' % base_dir)
            os.chdir('%s/Files' % base_dir)
            if options['git']:
                os.system("%sgit tag -a v%s -m '%s'" % ('sudo ' \
                            if options['git_root'] else '', timestamp,
                    time.strftime('snapshot from %d. %B %Y %H:%M:%S%z.', t)))
            print("%star -czf ../Snapshots/%s.tar.gz * .??*" % ('sudo ' \
                                        if root_snapshot else '', timestamp))
            os.system("%star -czf ../Snapshots/%s.tar.gz * .??*" % ('sudo ' \
                                        if root_snapshot else '', timestamp))
            print('--------------------------------------------------------------------------------')

def run_script(script):
    print('--------------------------------------------------------------------------------')
    send_notification('Start script "%s".' % script)
    print('starting script "%s".' % script)
    os.system(script)
    print('--------------------------------------------------------------------------------')

def _pass(path):
    if path:
        proc = subprocess.Popen('pass %s' % path, stdout=subprocess.PIPE, shell=True)
        (out, err) = proc.communicate()
        return out.decode('utf-8').split('\n')[0]
    else:
        return ''

def postgres_dump(options, pgsqls):
    print('--------------------------------------------------------------------------------')
    print('start dumping of PostgreSQL databases.')
    send_notification('start dumping backup of PostgreSQL databases.')

    timestamp = time.strftime('%Y%m%dT%H%M%S%z', time.localtime())
    for db in pgsqls:
        print('backup of: "%s"' % db['name'])
        current_target = db['target'] if 'target' in db \
                    else '%s/%s/DBDumps/PostgreSQL/%s' % (options['target'],
                            db['ssh'] if 'ssh' in db else socket.gethostname(),
                            db['name'])

        if not os.path.exists(current_target):
            os.makedirs(current_target)

        password = _pass(db['pass']) if 'pass' in db else db['password']
        os.system('%sPGPASSWORD=%s pg_dump --username=%s %s %s | gzip -c > %s' \
            % ('ssh %s ' % db['ssh'] if 'ssh' in db else '', password,
                db['user'], db['options'] if 'options' in db else '',
                db['name'], os.path.join(current_target,
                            '%s_%s.sql.gz' % (db['name'], timestamp))))
    print('--------------------------------------------------------------------------------')

def mysql_dump(options, mysqls):
    print('--------------------------------------------------------------------------------')
    print('start dumping of MySQL databases.')
    send_notification('start dumping of MySQL databases.')

    timestamp = time.strftime('%Y%m%dT%H%M%S%z', time.localtime())
    for db in mysqls:
        print('backup of: "%s"' % db['name'])
        current_target = db['target'] if 'target' in db \
                        else '%s/%s/DBDumps/MySQL/%s' % (options['target'],
                                db['ssh'] if 'ssh' in db \
                                    else socket.gethostname(), db['name'])

        if not os.path.exists(current_target):
            os.makedirs(current_target)

        password = _pass(db['pass']) if 'pass' in db else db['password']
        os.system('%smysqldump --user=%s --password=%s %s %s | gzip -c > %s' % \
                    ('ssh %s ' % db['ssh'] if 'ssh' in db else '',
                        db['user'], password, db['options'] if 'options' in db \
                        else '', db['name'], os.path.join(current_target,
                            '%s_%s.sql.gz' % (db['name'], timestamp))))
    print('--------------------------------------------------------------------------------')

def run():
    usage = 'usage: %prog [options]'
    parser = OptionParser(usage)
    parser.add_option('-t', '--target', action='store', type='string',
                dest='target')
    parser.add_option('-x', '--xml', action='store', type='string', dest='xml')
    parser.add_option('-v', '--is-valid', action='store_true',
                dest='check_valid', help='checks the given xml file on valid')
    parser.add_option('-d', '--no-database', action='store_true',
                dest='database', help='disables database dump')
    parser.add_option('-n', '--no-postgres', action='store_true',
                dest='postgres', help='disables PostgreSQL dump')
    parser.add_option('-m', '--no-mysql', action='store_true',
                dest='mysql', help='disables MySQL dump')
    parser.add_option('-s', '--snapshot', action='store_true',
                dest='snapshot', help='make snapshot')
    parser.add_option('-r', '--root-snapshot', action='store_true',
                dest='root_snapshot', help='make snapshot')
    (cmd_options, cmd_args) = parser.parse_args()

    pipeline = {}
    if cmd_options.xml != None:
        if cmd_options.check_valid:
            check_valid(cmd_options.xml, load(cmd_options.xml))
            print('xml file "%s" is valid.' % cmd_options.xml)
            sys.exit(0)
        else:
            options, sources, mysqls, pgsqls, pipeline = \
                    parse(cmd_options.xml, cmd_options.target)
    else:
        parser.print_help()

    for k, v in sorted(pipeline.items()):
        if v == 'backup':
            backup(options, sources, cmd_options.snapshot,
                    cmd_options.root_snapshot)
        elif v == 'db_dump' and not cmd_options.database:
            if not cmd_options.mysql:
                mysql_dump(options, mysqls)
            if not cmd_options.postgres:
                postgres_dump(options, pgsqls)
        elif v == 'postgres_dump' and \
                        not (cmd_options.postgres or cmd_options.database):
            postgres_dump(options, pgsqls)
        elif v == 'mysql_dump' and \
                        not (cmd_options.mysql or cmd_options.database):
            mysql_dump(options, mysqls)
        elif v == 'pre_backup_script':
            run_script(options['pre_backup_script'])
        elif v == 'post_backup_script':
            run_script(options['pre_backup_script'])

if __name__ == '__main__':
    Notify.init('psync')
    run()
