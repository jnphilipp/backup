#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Python wrapper for rsync to easily configure rsync.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
import re
import socket
import sys
import time

import gi
gi.require_version('Notify', '0.7')

from gi.repository import Notify
from lxml import etree
from math import ceil, floor
from optparse import OptionParser
from os import makedirs
from os.path import exists, join
from subprocess import Popen, PIPE, call


__author__ = 'jnphilipp'
__email__ = 'mail@jnphilipp.org'
__license__ = 'GPLv3'
__version__ = '0.1.4'


NAMESPACE = {'p':'http://jnphilipp.org/psync/'}
BOOLEAN_STATES = {'1':True, 'yes':True, 'true':True, 'on':True,
                    '0':False, 'no':False, 'false':False, 'off':False}


def get_boolean(string, default=False):
    return BOOLEAN_STATES[string] if string in BOOLEAN_STATES else default


def send_notification(message):
    """send messages to notify-osd"""
    try:
        notification = Notify.Notification.new('psync', message, 'deja-dup')
        notification.show()
    except:
        print(message)


def load(path):
    if not exists(path):
        print('xml file "%s" not found. aborting...' % path)
        sys.exit(1)
    return etree.parse(path)


def check_valid(path, doc):
    xmlschema = etree.XMLSchema(etree.parse('/usr/share/psync/psync.xsd'))
    if not xmlschema.validate(doc):
        print('xml file "%s" not valid. aborting...' % path)
        xmlschema.assertValid(doc)
        sys.exit(1)


def parse(path, target=None):
    doc = load(path)
    check_valid(path, doc)

    options = {'target':None, 'git':True, 'git_root':False, 'rsync_root':False}
    if doc.find('p:options/p:git', namespaces=NAMESPACE) is not None:
        o = doc.find('p:options/p:git', namespaces=NAMESPACE)
        options['git'] = get_boolean(o.text.strip(), True)
        if 'root' in o.attrib:
            options['git_root'] = get_boolean(o.attrib['root'].strip(), True)
    if doc.find('p:options/p:rsync', namespaces=NAMESPACE) is not None:
        o = doc.find('p:options/p:rsync', namespaces=NAMESPACE)
        options['rsync'] = o.text.strip()
        if 'root' in o.attrib:
            options['rsync_root'] = get_boolean(o.attrib['root'].strip(), False)
    if doc.find('p:options/p:target', namespaces=NAMESPACE) is not None:
        options['target'] = doc.find('p:options/p:target',
                                     namespaces=NAMESPACE).text.strip()
    if doc.find('p:options/p:pre_backup_script',
                namespaces=NAMESPACE) is not None:
        options['pre_backup_script'] = doc.find('p:options/p:pre_backup_script',
                                                namespaces=NAMESPACE).text.strip()
    if doc.find('p:options/p:post_backup_script',
                namespaces=NAMESPACE) is not None:
        options['post_backup_script'] = doc.find('p:options/p:post_backup_script',
                                                 namespaces=NAMESPACE).text.strip()

    if target:
        options['target'] = target

    pipeline = {}
    for step in doc.xpath('p:pipeline/*', namespaces=NAMESPACE):
        pipeline[int(step.attrib['no'].strip())] = step.text.strip()
        if pipeline[int(step.attrib['no'].strip())] == 'backup' and \
                not options['target']:
          print('no target provided. aborting...')
          sys.exit(1)

    sources = parse_sources(doc)
    pgsqls = parse_dbs(doc.xpath('p:databases/p:postgresql/*', namespaces=NAMESPACE))
    mysqls = parse_dbs(doc.xpath('p:databases/p:mysql/*', namespaces=NAMESPACE))
    parse_db_files(doc.xpath('p:databases/p:file', namespaces=NAMESPACE), mysqls, pgsqls)
    return (options, sources, mysqls, pgsqls, pipeline)


def parse_sources(doc):
    sources = []
    for s in doc.xpath('p:sources/p:source', namespaces=NAMESPACE):
        source = {'source': s.find('p:path', namespaces=NAMESPACE).text.strip()}
        if s.find('p:exclude', namespaces=NAMESPACE) is not None:
            source['exclude'] = [e.text.strip() for e in s.iterfind('p:exclude',
                                                                    namespaces=NAMESPACE)]
        if s.find('p:target', namespaces=NAMESPACE) is not None:
            source['target'] = s.find('p:target', namespaces=NAMESPACE).text.strip()
        if s.find('p:rsync', namespaces=NAMESPACE) is not None:
            o = s.find('p:rsync', namespaces=NAMESPACE)
            source['rsync'] = o.text.strip()
            if 'root' in o.attrib:
                source['root'] = get_boolean(o.attrib['root'].strip(), False)
        if s.find('p:post_script', namespaces=NAMESPACE) is not None:
            source['post_script'] = s.find('p:post_script',
                                           namespaces=NAMESPACE).text.strip()
        sources.append(source)

    for f in doc.xpath('p:sources/p:file', namespaces=NAMESPACE):
        fdoc = load(f.text.strip())
        check_valid(f.text.strip(), fdoc)
        s = parse_sources(fdoc)
        if 'root' in f.attrib:
            for i in s: i['root'] = get_boolean(f.attrib['root'], False)
        sources += s
    return sources


def parse_db_files(file_iter, mysqls, pgsqls):
    for f in file_iter:
        path = f.text.strip()
        doc = load(path)
        check_valid(path, doc)
        pgsqls += (parse_dbs(doc.xpath('p:databases/p:postgresql/*',
                                       namespaces=NAMESPACE)))
        mysqls += (parse_dbs(doc.xpath('p:databases/p:mysql/*', namespaces=NAMESPACE)))
        parse_db_files(doc.xpath('p:databases/p:file',
                                 namespaces=NAMESPACE), mysqls, pgsqls)


def parse_dbs(db_iter):
    dbs = []
    for c in db_iter:
        db = {'name': c.find('p:name', namespaces=NAMESPACE).text.strip(),
                'user': c.find('p:user', namespaces=NAMESPACE).text.strip()}
        if c.find('p:password', namespaces=NAMESPACE) is not None:
            db['password'] = c.find('p:password', namespaces=NAMESPACE).text.strip()
        if c.find('p:pass', namespaces=NAMESPACE) is not None:
            db['pass'] = c.find('p:pass', namespaces=NAMESPACE).text.strip()
        if c.find('p:target', namespaces=NAMESPACE) is not None:
            db['target'] = c.find('p:target', namespaces=NAMESPACE).text.strip()
        if c.find('p:options', namespaces=NAMESPACE) is not None:
            db['options'] = c.find('p:options', namespaces=NAMESPACE).text.strip()
        if c.find('p:ssh', namespaces=NAMESPACE) is not None:
            db['ssh'] = c.find('p:ssh', namespaces=NAMESPACE).text.strip()
        dbs.append(db)
    return dbs


def backup(options, sources, snapshot, root_snapshot):
    print('-' * 100)
    hostname = socket.gethostname()

    base_dirs = set()
    timestamp = time.strftime('%Y%m%dT%H%M%S%z', time.localtime())
    for source in sources:
        send_notification('Starting backup of "%s".' % source['source'])
        print('Backup of: %s' % source['source'])

        exclude = ''
        if 'exclude' in source:
            print('Excluding: %s' % ' '.join(['"%s"' % e for e in source['exclude']]))
            exclude = ' '.join('--exclude="%s"' % e for e in source['exclude'])
        current_rsync = source['rsync'] if 'rsync' in source else options['rsync']
        current_target = source['target'] if 'target' in source else options['target']
        rsync_root = source['root'] if 'root' in source else options['rsync_root']

        match = re.match(r'^([^/]+@)?[^/]+:', source['source'])
        if match:
            print('Is remote: %s' % source['source'])
            base_dir = '%s/%s' % (current_target, match.group(0)[:-1])
            base_dirs.add(base_dir)
            current_target += '/%s' % re.sub(r'^([^/]+@)?[^/]+:',
                                             '%s/Files' % match.group(0)[:-1],
                                             source['source'])
        else:
            base_dir = '%s/%s' % (current_target, hostname)
            base_dirs.add(base_dir)
            if os.path.isdir(source['source']):
                s = source['source']
            else:
                s = os.path.dirname(source['source'])
            current_target += '/%s/Files%s' % (hostname, s)

        if not exists(current_target):
            makedirs(current_target)
        current_target = '"%s"' % current_target

        if os.path.isdir(source['source']):
            s = '%s/' % source['source']
        else:
            s = source['source']
        rsync = '%srsync %s %s %s %s' % ('sudo ' if rsync_root else '',
                                         exclude, current_rsync, s, current_target)
        print(rsync)
        p = Popen(rsync, stdout=PIPE, stderr=PIPE, shell=True)

        out = ''
        while p.poll() is None:
            line = p.stdout.readline().decode('utf-8')
            out += line.split('\r')[-1]
            sys.stdout.write(line)
            sys.stdout.flush()
        err = ('\n%s' % p.communicate()[1].decode('utf-8')).strip()
        print()
        print('-' * 100)
        print('rsync errors\n%s'  % err)
        _write_logfile(base_dir, timestamp, rsync, out, err)

        if 'post_script' in source:
            print('-' * 100)
            send_notification('Start post script "%s".' % source['post_script'])
            print('Start post script "%s".'  % source['post_script'])
            os.system(source['post_script'])
        print('-' * 100)

    if options['git']:
        timestamp = time.strftime('%Y-%m-%dT%H:%M:%S%z', time.localtime())
        for base_dir in base_dirs:
            print('Commit changes in "%s"' % base_dir)
            os.chdir('%s/Files' % base_dir)
            if not os.system('%sgit rev-parse' % \
                             ('sudo ' if options['git_root'] else '')) == 0:
                os.system('%sgit init' % ('sudo ' if options['git_root'] else ''))

            if exists('.gitmodules'):
                _delete_gitmodules(options['git_root'])

            gits = _find_gits(options['git_root'])
            if gits:
                _write_gitmodules(gits)
            else:
                if exists('.gitmodules'):
                    os.remove('.gitmodules')

            os.system('%sgit add -A' % ('sudo ' if options['git_root'] else ''))
            os.system("%sgit commit -m 'backup from %s.'" % ('sudo ' \
                            if options['git_root'] else '', timestamp))
            print('-' * 100)

    if snapshot or root_snapshot:
        t = time.localtime()
        timestamp = time.strftime('%Y%m%dT%H%M%S%z', t)
        for base_dir in base_dirs:
            send_notification('Taking snapshot of "%s".' % base_dir)
            print('Taking snapshot of: "%s"' % base_dir)

            if not exists('%s/Snapshots' % base_dir):
                makedirs('%s/Snapshots' % base_dir)
            os.chdir('%s/Files' % base_dir)
            if options['git']:
                os.system("%sgit tag -a v%s -m '%s'" % ('sudo ' \
                            if options['git_root'] else '', timestamp,
                    time.strftime('snapshot from %d. %B %Y %H:%M:%S%z.', t)))
            print("%star -czf ../Snapshots/%s.tar.gz * .??*" % ('sudo ' \
                                        if root_snapshot else '', timestamp))
            os.system("%star -czf ../Snapshots/%s.tar.gz * .??*" % ('sudo ' \
                                        if root_snapshot else '', timestamp))
            print('-' * 100)


def run_script(script):
    print('-' * 100)
    send_notification('Start script "%s".' % script)
    print('Starting script "%s".' % script)
    call(script, shell=True)
    print('-' * 100)


def postgres_dump(options, pgsqls):
    print('-' * 100)
    print('Start dumping of PostgreSQL databases.')
    send_notification('Start dumping of PostgreSQL databases.')

    timestamp = time.strftime('%Y%m%dT%H%M%S%z', time.localtime())
    for db in pgsqls:
        print('Backup of: "%s"' % db['name'])
        current_target = db['target'] if 'target' in db \
                    else '%s/%s/DBDumps/PostgreSQL/%s' % (options['target'],
                            db['ssh'] if 'ssh' in db else socket.gethostname(),
                            db['name'])

        if not exists(current_target):
            makedirs(current_target)
        current_target = '"%s"' % current_target

        ssh = 'ssh %s ' % db['ssh'] if 'ssh' in db else ''
        user = '--username=%s' % db['user']
        if 'pass' in db:
            password = 'PGPASSWORD="%s"' % _pass(db['pass'])
        elif 'password' in db:
            password = 'PGPASSWORD="%s"' % db['password']
        else:
            password = ''
        os.system('%s%s pg_dump %s %s %s | gzip -c > %s' \
            % (ssh, password, user, db['options'] if 'options' in db else '',
               db['name'],
               join(current_target, '%s_%s.sql.gz' % (db['name'], timestamp))))
    print('-' * 100)


def mysql_dump(options, mysqls):
    print('-' * 100)
    print('Start dumping of MySQL databases.')
    send_notification('Start dumping of MySQL databases.')

    timestamp = time.strftime('%Y%m%dT%H%M%S%z', time.localtime())
    for db in mysqls:
        print('Backup of: "%s"' % db['name'])
        if 'target' in db:
            current_target = db['target']
        else:
            hostname = db['ssh'] if 'ssh' in db else socket.gethostname()
            current_target = '%s/%s/DBDumps/MySQL/%s' % (options['target'],
                                                         hostname,
                                                         db['name'])

        if not exists(current_target):
            makedirs(current_target)
        current_target = '"%s"' % current_target

        ssh = 'ssh %s ' % db['ssh'] if 'ssh' in db else ''
        user = '--user=%s' % db['user']
        if 'pass' in db:
            password = '--password=%s' % _pass(db['pass'])
        elif 'password' in db:
            password = '--password=%s' % db['password']
        else:
            password = ''
        os.system('%smysqldump %s %s %s %s | gzip -c > %s' % \
                    (ssh, user, password,
                     db['options'] if 'options' in db else '',
                     db['name'],
                     join(current_target, '%s_%s.sql.gz' % (db['name'], timestamp))))
    print('-' * 100)


def _delete_gitmodules(root=False):
    print('-' * 100)
    print('Deleting gitmodules')
    with open('.gitmodules', 'r') as f:
        for line in f:
            if line.startswith('    path = '):
                call('%sgit rm -r --cached "%s"' % ('sudo ' if root else '',
                                                    line[11:].strip()), shell=True)


def _write_gitmodules(submodules):
    print('Writing gitmodules')
    with open('.gitmodules', 'w') as f:
        for submodule in submodules.split('\n'):
            f.write('[submodule "%s"]\n' % os.path.basename(submodule))
            f.write('    path = %s\n' % submodule)
    print('-' * 100)


def _find_gits(root=False):
    p = Popen(('sudo ' if root else '') +
              'find . -type d \( -exec /usr/bin/test -d "{}/.git" -a ' +
              '"{}" != "." \; -print -prune -o -name .git -prune \)',
              stdout=PIPE, shell=True)
    return p.communicate()[0].decode('utf-8').strip()


def _pass(path):
    if path:
        p = Popen('pass %s' % path, stdout=PIPE, shell=True)
        return p.communicate()[0].decode('utf-8').split('\n')[0]
    else:
        return ''


def _write_logfile(base_dir, timestamp, rsync, out, err):
    log_dir = join(base_dir, 'Files', 'psync.logs')
    if not exists(log_dir):
        makedirs(log_dir)

    with open(join(log_dir, '%s.log' % timestamp), 'a', encoding='utf-8') as f:
        f.write('%s\n' % ('-' * 100))
        f.write('%s\n' % rsync)
        f.write('%s\n' % ('-' * 100))
        f.write('%s\n' % out)
        f.write('%s\n' % ('-' * 100))
        f.write('%s\n' % err)
        f.write('%s\n' % ('-' * 100))


def run():
    usage = 'usage: %prog [options]'
    parser = OptionParser(usage)
    parser.add_option('-t', '--target', action='store', type='string',
                dest='target')
    parser.add_option('-x', '--xml', action='store', type='string', dest='xml')
    parser.add_option('-v', '--is-valid', action='store_true',
                dest='check_valid', help='checks the given xml file on valid')
    parser.add_option('-d', '--no-database', action='store_true',
                dest='database', help='disables database dump')
    parser.add_option('-p', '--no-postgres', action='store_true',
                dest='postgres', help='disables PostgreSQL dump')
    parser.add_option('-m', '--no-mysql', action='store_true',
                dest='mysql', help='disables MySQL dump')
    parser.add_option('-s', '--snapshot', action='store_true',
                dest='snapshot', help='make snapshot')
    parser.add_option('-r', '--root-snapshot', action='store_true',
                dest='root_snapshot', help='make snapshot')
    parser.add_option('--version', action='store_true', dest='version',
                help='show version information')
    (cmd_options, cmd_args) = parser.parse_args()

    pipeline = {}
    if cmd_options.xml != None:
        if cmd_options.check_valid:
            check_valid(cmd_options.xml, load(cmd_options.xml))
            print('xml file "%s" is valid.' % cmd_options.xml)
            sys.exit(0)
        else:
            options, sources, mysqls, pgsqls, pipeline = \
                    parse(cmd_options.xml, cmd_options.target)
    elif cmd_options.version:
        github = 'https://github.com/jnphilipp/psync'
        print('###########################################')
        print('#                  psync                  #')
        print('#           python rsync wrapper          #')
        print('#                                         #')
        print('#%s%s%s#' % (' ' * floor((40 - len(__version__)) / 2),
                            'v%s' % __version__,
                            ' ' * ceil((40 - len(__version__)) / 2)))
        print('#%s%s%s#' % (' ' * floor((41 - len(__license__)) / 2),
                            __license__,
                            ' ' * ceil((41 - len(__license__)) / 2)))
        print('#                                         #')
        print('#%s%s%s#' % (' ' * floor((41 - len(__author__)) / 2),
                            __author__,
                            ' ' * ceil((41 - len(__author__)) / 2)))
        print('#%s%s%s#' % (' ' * floor((41 - len(__email__)) / 2),
                            __email__,
                            ' ' * ceil((41 - len(__email__)) / 2)))
        print('#                                         #')
        print('#%s%s%s#' % (' ' * floor((41 - len(github)) / 2),
                            github,
                            ' ' * ceil((41 - len(github)) / 2)))
        print('###########################################')
    else:
        parser.print_help()

    for k, v in sorted(pipeline.items()):
        if v == 'backup':
            backup(options, sources, cmd_options.snapshot,
                    cmd_options.root_snapshot)
        elif v == 'db_dump' and not cmd_options.database:
            if not cmd_options.mysql:
                mysql_dump(options, mysqls)
            if not cmd_options.postgres:
                postgres_dump(options, pgsqls)
        elif v == 'postgres_dump' and \
                        not (cmd_options.postgres or cmd_options.database):
            postgres_dump(options, pgsqls)
        elif v == 'mysql_dump' and \
                        not (cmd_options.mysql or cmd_options.database):
            mysql_dump(options, mysqls)
        elif v == 'pre_backup_script':
            run_script(options['pre_backup_script'])
        elif v == 'post_backup_script':
            run_script(options['pre_backup_script'])

if __name__ == '__main__':
    Notify.init('psync')
    run()
