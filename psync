#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
import re
import socket
import subprocess
import sys
import time

from gi.repository import Notify
from lxml import etree
from optparse import OptionParser

NAMESPACE = {'p':'http://jnphilipp.org/psync/'}
BOOLEAN_STATES = {'1':True, 'yes':True, 'true':True, 'on':True, '0':False, 'no':False, 'false':False, 'off':False}

def send_notification(message):
    """send messages to notify-osd"""
    try:
        notification = Notify.Notification.new('psync', message, 'deja-dup')
        notification.show()
    except:
        print(message)

def load(path):
    if not os.path.exists(path):
        print('xml file "%s" not found. aborting...' % path)
        sys.exit(1)
    return etree.parse(path)

def check_valid(path, doc):
    xmlschema = etree.XMLSchema(etree.parse('/usr/share/psync/psync.xsd'))
    if not xmlschema.validate(doc):
        print('xml file "%s" not valid. aborting...' % path)
        sys.exit(1)

def parse(path, target=None):
    doc = load(path)
    check_valid(path, doc)

    options = {'target':None, 'git':True, 'git_root':False}
    for o in doc.xpath('p:options/*', namespaces=NAMESPACE):
        options[o.attrib['name'].strip()] = o.text.strip()

        if o.attrib['name'].strip() == 'git':
            options[o.attrib['name'].strip()] = \
                    BOOLEAN_STATES[o.text.strip().lower()] if \
                        o.text.strip().lower() in BOOLEAN_STATES else True
        if o.attrib['name'].strip() == 'git' and \
                    'root' in o.attrib['name'].strip():
            options['git_root'] = \
                    BOOLEAN_STATES[o.attrib['root'].strip()] if \
                            o.attrib['root'].strip() in BOOLEAN_STATES else True

    if target:
        options['target'] = target

    pipeline = {}
    for step in doc.xpath('p:pipeline/*', namespaces=NAMESPACE):
        pipeline[int(step.attrib['no'].strip())] = step.text.strip()
        if pipeline[int(step.attrib['no'].strip())] == 'backup' and \
                not options['target']:
          print('no target provided. aborting...')
          sys.exit(1)

    sources = []
    for s in doc.xpath('p:sources/*', namespaces=NAMESPACE):
        source = {'source': s.find('p:path', namespaces=NAMESPACE).text.strip()}
        if s.find('p:exclude', namespaces=NAMESPACE) is not None:
            source['exclude'] = [e.text.strip() for e in s.iterfind('p:exclude', namespaces=NAMESPACE)]
        if s.find('p:target', namespaces=NAMESPACE) is not None:
            source['target'] = s.find('p:target', namespaces=NAMESPACE).text.strip()
        if s.find('p:rsync_options', namespaces=NAMESPACE) is not None:
            source['rsync_options'] = s.find('p:rsync_options', namespaces=NAMESPACE).text.strip()
        if s.find('p:post_script', namespaces=NAMESPACE) is not None:
            source['post_script'] = s.find('p:post_script', namespaces=NAMESPACE).text.strip()
        sources.append(source)

    pgsqls = parse_dbs(doc.xpath('p:databases/p:postgresql/*',
                                namespaces=NAMESPACE))
    mysqls = parse_dbs(doc.xpath('p:databases/p:mysql/*',
                                namespaces=NAMESPACE))
    parse_db_files(doc.xpath('p:databases/p:file',
                            namespaces=NAMESPACE), mysqls, pgsqls)
    return (options, sources, mysqls, pgsqls, pipeline)

def parse_db_files(file_iter, mysqls, pgsqls):
    for f in file_iter:
        path = f.text.strip()
        doc = load(path)
        check_valid(path, doc)
        pgsqls += (parse_dbs(doc.xpath('p:databases/p:postgresql/*',
                                namespaces=NAMESPACE)))
        mysqls += (parse_dbs(doc.xpath('p:databases/p:mysql/*',
                                namespaces=NAMESPACE)))
        parse_db_files(doc.xpath('p:databases/p:file',
                                namespaces=NAMESPACE), mysqls, pgsqls)

def parse_dbs(db_iter):
    dbs = []
    for c in db_iter:
        db = {'name': c.find('p:name', namespaces=NAMESPACE).text.strip(),
                'user': c.find('p:user', namespaces=NAMESPACE).text.strip()}
        if c.find('p:password', namespaces=NAMESPACE) is not None:
            db['password'] = c.find('p:password', namespaces=NAMESPACE).text.strip()
        if c.find('p:pass', namespaces=NAMESPACE) is not None:
            db['pass'] = c.find('p:pass', namespaces=NAMESPACE).text.strip()
        if c.find('p:target', namespaces=NAMESPACE) is not None:
            db['target'] = c.find('p:target', namespaces=NAMESPACE).text.strip()
        if c.find('p:options', namespaces=NAMESPACE) is not None:
            db['options'] = c.find('p:options', namespaces=NAMESPACE).text.strip()
        if c.find('p:ssh', namespaces=NAMESPACE) is not None:
            db['ssh'] = c.find('p:ssh', namespaces=NAMESPACE).text.strip()
        dbs.append(db)
    return dbs

def backup(options, sources, snapshot, root):
    print('--------------------------------------------------------------------------------')
    hostname = socket.gethostname()

    base_dirs = set()
    for source in sources:
        send_notification('starting backup of "%s".' % source['source'])
        print('backup of: %s' % source['source'])

        exclude = ''
        if 'exclude' in source:
            print('excluding: %s' % ' '.join('"%s"' % exclude for exclude in source['exclude']))
            exclude = ' '.join('--exclude="%s"' % exclude for exclude in source['exclude'])
        current_rsync_options = source['rsync_options'] if 'rsync_options' in source else options['rsync_options']
        current_target = source['target'] if 'target' in source else options['target']

        match = re.match(r'^([^/]+@)?[^/]+:', source['source'])
        if match:
            print('is remote: %s' % source['source'])
            base_dirs.add('%s/%s' % (current_target, match.group(0)[:-1]))
            current_target += '/%s' % re.sub(r'^([^/]+@)?[^/]+:', '%s/Files' % match.group(0)[:-1], source['source'])
        else:
            base_dirs.add('%s/%s' % (current_target, hostname))
            current_target += '/%s/Files%s' % (hostname, source['source'] if os.path.isdir(source['source']) else os.path.dirname(source['source']))

        if not os.path.exists(current_target):
            os.makedirs(current_target)

        rsync = 'rsync %s %s %s %s' % (exclude, current_rsync_options, '%s/' % source['source'] if os.path.isdir(source['source']) else source['source'], current_target)
        print(rsync)
        os.system(rsync)

        if 'post_script' in source:
            print('--------------------------------------------------------------------------------')
            send_notification('start post script "%s".' % source['post_script'])
            print('start post script "%s".'  % source['post_script'])
            os.system(source['post_script'])
        print('--------------------------------------------------------------------------------')

    if 'git' in options and options['git']:
        timestamp = time.strftime('%Y-%m-%dT%H:%M:%S%z', time.localtime())
        for base_dir in base_dirs:
            print('commit changes in "%s"' % base_dir)
            os.chdir('%s/Files' % base_dir)
            if not os.system('git rev-parse') == 0:
                os.system('git init')
            os.system('%sgit add -A' % ('sudo ' if root or ('git_root' in options and options['git_root']) else ''))
            os.system("%sgit commit -m 'backup from %s.'" % ('sudo ' if root or ('git_root' in options and options['git_root']) else '', timestamp))
            print('--------------------------------------------------------------------------------')

    if snapshot:
        t = time.localtime()
        timestamp = time.strftime('%Y%m%dT%H%M%S%z', t)
        for base_dir in base_dirs:
            send_notification('taking snapshot of "%s".' % base_dir)
            print('taking snapshot of: "%s"' % base_dir)

            if not os.path.exists('%s/Snapshots' % base_dir):
                os.makedirs('%s/Snapshots' % base_dir)
            os.chdir('%s/Files' % base_dir)
            if 'git' in options and options['git']:
                os.system("%sgit tag -a v%s -m '%s'" % ('sudo ' if root or ('git_root' in options and options['git_root']) else '', timestamp, time.strftime('snapshot from %d. %B %Y %H:%M:%S%z.', t)))
            os.system("%s tar -czf ../Snapshots/%s.tar.gz * .??*" % ('sudo' if root else '', timestamp))
            print('--------------------------------------------------------------------------------')

def run_script(script):
    print('--------------------------------------------------------------------------------')
    send_notification('Start script "%s".' % script)
    print('starting script "%s".' % script)
    os.system(script)
    print('--------------------------------------------------------------------------------')

def _pass(path):
    if path:
        proc = subprocess.Popen('pass %s' % path, stdout=subprocess.PIPE, shell=True)
        (out, err) = proc.communicate()
        return out.decode('utf-8').split('\n')[0]
    else:
        return ''

def postgres_dump(options, pgsqls):
    print('--------------------------------------------------------------------------------')
    print('start dumping of PostgreSQL databases.')
    send_notification('start dumping backup of PostgreSQL databases.')

    timestamp = time.strftime('%Y%m%dT%H%M%S%z', time.localtime())
    for db in pgsqls:
        print('backup of: "%s"' % db['name'])
        current_target = db['target'] if 'target' in db else '%s/%s/DBDumps/PostgreSQL/%s' % (options['target'], db['ssh'] if 'ssh' in db else socket.gethostname(), db['name'])

        if not os.path.exists(current_target):
            os.makedirs(current_target)

        password = _pass(db['pass']) if 'pass' in db else db['password']
        os.system('%sPGPASSWORD=%s pg_dump --username=%s %s %s | gzip -c > %s' % ('ssh %s ' % db['ssh'] if 'ssh' in db else '', password, db['user'], db['options'] if 'options' in db else '', db['name'], os.path.join(current_target, '%s_%s.sql.gz' % (db['name'], timestamp))))
    print('--------------------------------------------------------------------------------')

def mysql_dump(options, mysqls):
    print('--------------------------------------------------------------------------------')
    print('start dumping of MySQL databases.')
    send_notification('start dumping of MySQL databases.')

    timestamp = time.strftime('%Y%m%dT%H%M%S%z', time.localtime())
    for db in mysqls:
        print('backup of: "%s"' % db['name'])
        current_target = db['target'] if 'target' in db else '%s/%s/DBDumps/MySQL/%s' % (target, db['ssh'] if 'ssh' in db else socket.gethostname(), db['name'])

        if not os.path.exists(current_target):
            os.makedirs(current_target)

        password = _pass(db['pass']) if 'pass' in db else db['password']
        os.system('%smysqldump --user=%s --password=%s %s %s | gzip -c > %s' % ('ssh %s ' % db['ssh'] if 'ssh' in db else '', db['user'], password, db['options'] if 'options' in db else '', db['name'], os.path.join(current_target, '%s_%s.sql.gz' % (db['name'], timestamp))))
    print('--------------------------------------------------------------------------------')

def run():
    usage = 'usage: %prog [options]'
    parser = OptionParser(usage)
    parser.add_option('-t', '--target', action='store', type='string', dest='target')
    parser.add_option('-x', '--xml', action='store', type='string', dest='xml')
    parser.add_option('-v', '--is_valid', action='store_true', dest='check_valid', help='checks the given xml file on valid')
    parser.add_option('-d', '--no-database', action='store_true', dest='database', help='disables database dump')
    parser.add_option('-n', '--no-postgres', action='store_true', dest='postgres', help='disables PostgreSQL dump')
    parser.add_option('-m', '--no-mysql', action='store_true', dest='mysql', help='disables MySQL dump')
    parser.add_option('-s', '--snapshot', action='store_true', dest='snapshot', help='make snapshot')
    parser.add_option('-r', '--root', action='store_true', dest='root', help='make snapshot and git add as root')
    (cmd_options, cmd_args) = parser.parse_args()

    if cmd_options.xml != None:
        if cmd_options.check_valid:
            check_valid(cmd_options.xml, load(cmd_options.xml))
            print('xml file "%s" is valid.' % cmd_options.xml)
            sys.exit(0)
        else:
            options, sources, mysqls, pgsqls, pipeline = \
                    parse(cmd_options.xml, cmd_options.target)
    else:
        parser.print_help()

    for k, v in sorted(pipeline.items()):
        if v == 'backup':
            backup(options, sources, cmd_options.snapshot, cmd_options.root)
        elif v == 'db_dump' and not cmd_options.database:
            if not cmd_options.mysql:
                mysql_dump(options, mysqls)
            if not cmd_options.postgres:
                postgres_dump(options, pgsqls)
        elif v == 'postgres_dump' and not (cmd_options.postgres or cmd_options.database):
            postgres_dump(options, pgsqls)
        elif v == 'mysql_dump' and not (cmd_options.mysql or cmd_options.database):
            mysql_dump(options, mysqls)
        elif v == 'pre_backup_script':
            run_script(options['pre_backup_script'])
        elif v == 'post_backup_script':
            run_script(options['pre_backup_script'])

if __name__ == '__main__':
    Notify.init('psync')
    run()
